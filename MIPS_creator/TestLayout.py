# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TestLayout.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from copy import deepcopy
from time import sleep
from .collapsibleBox import CollapsibleBox
from .RowTypes import *
from .utilities import set_Test,settings

class Test(QtWidgets.QWidget): 
    def __init__(self,index,parent,TopRow=None): 
        super(QtWidgets.QWidget, self).__init__() 
        self.parent=parent
        if TopRow is None or TopRow.TestName.text()=="": self._name="Test"
        else: self._name = TopRow.TestName.text()
        self.TopRow=TopRow
        self._index=index
        self.setupUi()

    @property
    def name(self): return self._name
    @name.setter
    def name(self,s):
        if s == "": self._name = "Test"
        else: self._name=s
        self.HidingBox.toggle_button.setText("%s - %s"%(self.name,self.index))
    def setName(self,s):
        self.name=s
    @property
    def index(self): return self._index
    @index.setter
    def index(self,i):
        self._index=i
        self.HidingBox.indexUpdated(i)
        self.HidingBox.toggle_button.setText("%s - %s"%(self.name,self.index))

    def setupUi(self):
        self.setObjectName("test") 
        self.setMinimumWidth(650)
        self.verticalLayout = QtWidgets.QVBoxLayout(self) 
        self.verticalLayout.setObjectName("verticalLayout")
        self.verticalLayout.setContentsMargins(0,0,0,0)
        self.verticalLayout.setSpacing(0)
        if self.TopRow is None:self.TopRow=TestTopRow()
        
        self.HidingBox=CollapsibleBox("%s - %s"%(self.name,self.index),index=self.index)
        self.HidingBox.content_area.layout().setContentsMargins(20,0,10,0)
        
        self.verticalLayout.addWidget(self.HidingBox)

        self.TopRow.TestName.textChanged.connect(self.setName)
        self.HidingBox.addWidget(self.TopRow)
        self.allUserInput  = CollapsibleBox("User Input"        ,self.HidingBox, lambda: self.addRow(UserInputRow))
        self.DataInput     = CollapsibleBox("Data Input"        ,self.HidingBox, lambda: self.addRow(DataRow     ))
        self.InputRegisters= CollapsibleBox("Input Registers"   ,self.HidingBox, lambda: self.addRow(RegisterRow ))
        self.Outputs       = CollapsibleBox("Output Registers"  ,self.HidingBox, lambda: self.addRow(OutputRow   ))

        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("Icons/add.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        
        self.TopRow.CopyButton.pressed.connect(self.Copy) 
        self.TopRow.DeleteButton.pressed.connect(self.deleteSelf)

        self.verticalLayout.addStretch()
        self.retranslateUi() 
    

    def deleteSelf(self): 
        self.parent.deleteTest(self)
    
    
    def ExpandAndCollapseAll(self,expand):
        toggleAll_animation = QtCore.QParallelAnimationGroup(self)

        toggleAll_animation.setDirection(
            QtCore.QAbstractAnimation.Forward if expand else QtCore.QAbstractAnimation.Backward)

        if self.HidingBox.isOpen: hbox_ch=self.HidingBox.content_height
        else: hbox_ch=0
        
        if not expand: #Hiding box need to be first when collapsing and last when Expanding
            for anim in self.ExpandAndCollapseAll_AnimationSet(self.HidingBox,expand): toggleAll_animation.addAnimation(anim)

        for anim in self.ExpandAndCollapseAll_AnimationSet(self.allUserInput,expand): toggleAll_animation.addAnimation(anim)
        for anim in self.ExpandAndCollapseAll_AnimationSet(self.DataInput,expand): toggleAll_animation.addAnimation(anim)
        for anim in self.ExpandAndCollapseAll_AnimationSet(self.InputRegisters,expand): toggleAll_animation.addAnimation(anim)
        for anim in self.ExpandAndCollapseAll_AnimationSet(self.Outputs,expand): toggleAll_animation.addAnimation(anim)
        self.allUserInput.isOpen=expand
        self.DataInput.isOpen=expand
        self.InputRegisters.isOpen=expand
        self.Outputs.isOpen=expand

        if expand: 
            for anim in self.ExpandAndCollapseAll_AnimationSet(self.HidingBox,expand, override=self.HidingBox.isOpen, startHeightOffset=hbox_ch): 
                toggleAll_animation.addAnimation(anim)
        
        self.HidingBox.isOpen=expand
        
        toggleAll_animation.start()
        
        self.HidingBox.updateAnimation(0, self.HidingBox.content_height)


    
    def ExpandAndCollapseAll_AnimationSet(self, box:CollapsibleBox, expand, dur=0, override=False, startHeightOffset=0):
        if not override:
            if box.isClosed and not expand: return
            if box.isOpen and expand: return

        if dur<=0: dur=box.animationDuration
        anim = QtCore.QPropertyAnimation(box, b"minimumHeight")
        anim.setDuration(dur)
        anim.setStartValue(box.collapsed_height + startHeightOffset)
        anim.setEndValue(box.collapsed_height + box.content_height )
        yield anim

        anim = QtCore.QPropertyAnimation(box, b"maximumHeight")
        anim.setDuration(dur)
        anim.setStartValue(box.collapsed_height + startHeightOffset)
        anim.setEndValue(box.collapsed_height + box.content_height )
        yield anim
        
        anim = QtCore.QPropertyAnimation(box.content_area, b"maximumHeight")
        anim.setDuration(dur)
        anim.setStartValue(0 + startHeightOffset)
        anim.setEndValue(box.content_height )
        yield anim
    

    #TODO make the add user input button work
    def addRow(self,rowType,row=None,**kwargs):
        row:Row
        if rowType is None and row is None: raise Exception("either row or rowType must be defined")
        if row is not None: rowType=type(row)
        
        if rowType is UserInputRow:  destination=self.allUserInput
        elif rowType is DataRow:     destination=self.DataInput
        elif rowType is RegisterRow: destination=self.InputRegisters
        elif rowType is OutputRow:   destination=self.Outputs
        else: raise Exception("unusable type %s"%rowType)
        
        if row is None: row=rowType(parent=destination,**kwargs)
        else: row.parent = destination
        row.Deleted.connect(self.rowDeleted)
        return row

   
    def rowDeleted(self, row,box):
        box.updateHeight(row,Forward=False)

    
    def Copy(self):
        newTest = deepcopy(self)
        self.parent.addTest(newTest)

    def retranslateUi(self): 
        pass

    def convertToJSON(self,setting:settings): 
        test_setting=set_Test(parent=setting)
        test_setting.head_init(**self.TopRow.GetKwargs())

        self.setJSONKwargs(
            setFunction=test_setting.AddUserInput,
            layout=self.allUserInput.content_area.layout(),
            allowedtype=UserInputRow
        )
        
        self.setJSONKwargs(
            setFunction=test_setting.AddMemInput,
            layout=self.DataInput.content_area.layout(),
            allowedtype=DataRow
        )
        
        self.setJSONKwargs(
            setFunction=test_setting.AddRegInput,
            layout=self.InputRegisters.content_area.layout(),
            allowedtype=RegisterRow
        )
        
        self.setJSONKwargs(
            setFunction=test_setting.AddOutput,
            layout=self.Outputs.content_area.layout(),
            allowedtype=OutputRow
        )
        return test_setting
        
    """
    Used to convert each row to a settings.Test row
    setFunction = the settings.Test destination
    layout = the QT row layout to look through
    allowedType = The required row type #TODO verify functionality if this is repalced with None
    """	
    def setJSONKwargs(self, setFunction, layout, allowedtype):
        items = [layout.itemAt(i).widget() for i in range(layout.count()) ]
        for item in items: 
            if type(item) is not allowedtype: continue
            setFunction(**item.getKwargs())
        return
         
    def __deepcopy__(self,_):
        topRow=self.TopRow.copy()
        copy = Test(index=self.index,parent=self.parent,TopRow=topRow)
        
        lay=self.allUserInput.content_area.layout()
        items = [lay.itemAt(i).widget() for i in range(lay.count()) ]
        for item in items: 
            i=type(item)
            if i is not UserInputRow: continue
            copy.addRow(UserInputRow, row=item.copy())
        
        lay=self.DataInput.content_area.layout()
        items = [lay.itemAt(i).widget() for i in range(lay.count()) ]
        for item in items: 
            i=type(item)
            if i is not DataRow: continue
            copy.addDataRow(item.copy())
        
        lay=self.InputRegisters.content_area.layout()
        items = [lay.itemAt(i).widget() for i in range(lay.count()) ]
        for item in items: 
            i=type(item)
            if i is not RegisterRow: continue
            copy.addRegisterRow(item.copy())
        
        lay=self.Outputs.content_area.layout()
        items = [lay.itemAt(i).widget() for i in range(lay.count()) ]
        for item in items: 
            i=type(item)
            if i is not OutputRow: continue
            copy.addOutputRow(item.copy())

        return copy